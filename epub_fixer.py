import ebooklib 
from ebooklib import epub as ep
from pathlib import Path
import re
import uuid
import xml.etree.ElementTree as ET
import ast

INPUT_FOLDER = "./epubs/input"
OUTPUT_FOLDER = "./epubs/output"


REMOVE = [
    '<h6 style="text-align: left;">Generated by <a href="https://novelget.com">NovelGet.com</a></h6>', 
    '??e??e???v?l.???'
]

REPLACE = {

    'Bai s.h.i.+s.h.i.+':'Bai Shishi',
    'shi.+':'shi',

}





class EpubFixer:
    '''A class that fixes epubs'''
    def __init__(self, printing=True, make_folders=True):
        self.printing = printing
        if make_folders: self.make_folders()

    def fix(self, epub_path, output_folder, replace_dict=None, remove_list=None, split:int=400, author:str=''):
        '''Fixes the given book'''
        if self.printing: print("Fixing ebook:", epub_path, end='')
        
        ## Getting the data from the the epub
        book = ep.read_epub(epub_path)
        title = book.get_metadata('DC', 'title')
        title = str(title[0][0])
        author = author

        # Making the chapters 
        chapter_nr = 0
        chapters = []
        intro = None
        cover = None
        for item in book.get_items():
            if item.get_type() == ebooklib.ITEM_DOCUMENT:
                chapter = None
                if item.id == "cover": # Identifying the cover page
                    chapter_nr = -1
                    cover_chap = True
                    continue
                else: 
                    cover_chap = False
                if item.file_name == "intro.xhtml": # Identifying the intro page
                    chapter_nr = -1
                    intro_chap = True
                else:
                    intro_chap = False
                chapter_nr += 1


                print(item.__dict__)
                chapter_body = item.get_body_content()
                chapter_lang = item.lang if item.lang else 'en'

                # Fixing the body:
                chapter_body = chapter_body.decode('utf-8')
                if replace_dict: # Replaces some special stuff
                    for f,r in replace_dict.items(): 
                        chapter_body = re.sub(f, r, chapter_body)

                if remove_list: # removes stuff
                    for r in remove_list:
                        chapter_body = chapter_body.replace(r, '')

                chapter_body = EpubFixer.replace_sensored(chapter_body)
                chapter_body = EpubFixer.replace_br_with_paragraph(chapter_body)
                chapter_body = EpubFixer.replace_bad_puntuation(chapter_body)
                chapter_body = re.sub(r"b'[.\s\S]*?<p>", '<p>', str(chapter_body)) # Remove som stuff at the start
                chapter_body = re.sub(r'.*<br\/>', '', str(chapter_body))
                chapter_body = re.sub(r"'b", '', str(chapter_body))
                print(chapter_body)
                chapter_title = EpubFixer.get_title(item) # must be after the sensoring and stuff due to formating 
                chapter_body = re.sub("<p>\s*" + chapter_title + '\s*</p>', '', str(chapter_body)) # Removing some chapter titles that is not needed
                chapter_body = re.sub(r"^[.\s\S]*?<p>", '<p>', str(chapter_body)) # removing anything befor the first paragraph
                chapter_body = chapter_body.strip()
                if chapter_body[-1] == "'": chapter_body = chapter_body[:-1]
                chapter_body += '</p>' # added at the end
                chapter_body = f'<h2>{chapter_title}</h2>' + chapter_body # Adding the chapter title
                print(chapter_body)

                chapter = ep.EpubHtml(title=chapter_title, file_name="chapter_" + f"{chapter_nr:0>5}" + '.xhtml',lang=chapter_lang)
                chapter.set_content(chapter_body)
                chapters.append(chapter)

                if chapter_nr > 2: break

                print('='*80)
        
        ## Making the new books
        new_book = None
        for chapter in chapters: 
            if not new_book: # Seting up the new book
                new_book = ep.EpubBook() # The new book that should be the output
                new_book.set_identifier(str(uuid.uuid4()))
                new_book.set_title(str(title))
                new_book.set_language('en')
                new_book.add_metadata('DC', 'description', 'This is description for my book')
            new_book.add_item(chapter)

        style = 'body { font-family: Times, Times New Roman, serif; }'

        nav_css = ep.EpubItem(uid="style_nav",
                                file_name="style/nav.css",
                                media_type="text/css",
                                content=style)
        new_book.add_item(nav_css)
        new_book.spine = chapters
        book.add_item(ep.EpubNcx())
        book.add_item(ep.EpubNav())

        # Writing the epub
        output_path = Path(output_folder) / ("test.epub")
        ep.write_epub(output_path, new_book, {})


    @staticmethod
    def get_title(item) -> str:
        '''Returns the text body of an item'''
        res = [item.title]
        #if res != '' or res != []: return res

        chapter_body = item.get_body_content()
        chapter_body.decode('utf-8')
        chapter_body = EpubFixer.replace_sensored(str(chapter_body))

        regex = '<title>(.*)<\/title>'
        res += re.findall(regex, chapter_body)
        print(res)

        regex = '(Chapter\s*\d*[\w\s\:]*)(?=<)'
        res += re.findall(regex, chapter_body)

        print(res)
        if res != '' or res != []: return max(res, key=len).strip()
        return ''





    @staticmethod
    def find_regex(epub_path:str, regex:str) -> dict:
        '''returns all hits for the regex in the epub - used to identigy what to replace'''
        pattern = re.compile(regex, flags=0) # to make it faster
        pattern = re.compile('.{0,10}' + regex + '.{0,10}')
        
        book = ep.read_epub(epub_path)
        for item in book.get_items():
            if item.get_type() == ebooklib.ITEM_DOCUMENT:
                #print('==================================')
                #print('NAME : ', item.get_name())
                #print(item.get_content())
                res = pattern.findall(str(item.get_content()))
                if len(res) > 0: 
                    print(res)
                #print(item.get_content())
                #print(EpubFixer.replace_br_with_paragraph(str(item.get_content())))
                print('_______________________')

    @staticmethod
    def replace_bad_puntuation(text:str) -> str:
        '''replaces somthing . sdfea with something. sdfadf'''
        return re.sub(r'\s\.', '.', text)

    @staticmethod
    def replace_br_with_paragraph(text:str) -> str:
        '''replaces <br/> with paragraph around'''
        pattern = r"<br/><br/><br/>"
        replace_with = r'</p>\n<p>'
        res =  re.sub(pattern, replace_with, text)
        res = re.sub(r'</body>', '</p></body>', res) # the end case
        res = re.sub(r"</p>", "", res, 1) # the first case


        #res =  re.sub(r'(\S.*?)?<br/>\s*', r'<p>\1</p>\n', text)
        return res


    @staticmethod
    def replace_sensored(text:str) -> str:
        '''Replaces sensored text (H.e.l.l) -> Hell'''
        return re.sub(r'\.(\w)', r'\1', text)

    @staticmethod
    def find_epubs(path) -> str:
        '''Finds epubs in the folder'''
        path = Path(path)
        p = path.glob('**/*')
        epubs = [x for x in p if x.is_file()]
        epubs = [x for x in epubs if x.suffix == '.epub']
        return epubs

    @staticmethod
    def make_folders(input_folder:str=INPUT_FOLDER, output_folder:str=OUTPUT_FOLDER) -> None:
        '''Makes the folders for the system - Really just a utils function'''
        Path(input_folder).mkdir(parents=True, exist_ok=True)
        Path(output_folder).mkdir(parents=True, exist_ok=True)

print('test')

if __name__=="__main__":
    fixer = EpubFixer()
    epubs = fixer.find_epubs(INPUT_FOLDER)
    for epub in epubs:
        #fixer.find_regex(epub, '\\[0-9a-z]{3}')
        print('test')
        fixer.fix(epub_path=epub, output_folder=OUTPUT_FOLDER, replace_dict=REPLACE, remove_list=REMOVE)