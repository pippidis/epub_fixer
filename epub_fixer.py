import ebooklib 
from ebooklib import epub as ep
from pathlib import Path
import re
import uuid
import xml.etree.ElementTree as ET
import ast

INPUT_FOLDER = "./epubs/input"
OUTPUT_FOLDER = "./epubs/output"


REMOVE = [
    '<h6 style="text-align: left;">Generated by <a href="https://novelget.com">NovelGet.com</a></h6>', 
    '??e??e???v?l.???'
    '.+'
]

REPLACE = {
    '\.\+':'',
    'Bai s\.h\.i\.\+s\.h\.i\.\+':'Bai Shishi',
    'shi Feng':'Shi Feng'
}

DESCRIPTION = '''
<p>Long Chen, a crippled youth who cannot cultivate, is constantly targeted and bullied by his fellow noble heirs. After a particularly vicious beating, he wakes up and realizes a Pill God’s soul has somehow merged with him, giving him some additional memories. Within those memories is the mysterious Nine Star Hegemon Body Art, a cultivation technique that even he can train in, but whose secrets and origin are still a mystery to him. Relying on his improved instincts as he finally begins to cultivate, he realizes a huge conspiracy is underfoot within the Phoenix Cry Empire, one involving his father, members of the imperial family, and even the Emperor himself.</p>
<p>In order to solve the mysteries around him, he must rely on his new alchemy techniques and the powerful but baffling Nine Star Hegemon Body Art. Countless enemies block him as he attempts to climb to the peak of the cultivation world.</p>
<p>Fate destined him to be only a chess piece, but he would not bow to the will of the Heavens.</p>
'''

TITLE = "Nine Start Hegemon Body Arts"

VOLUMES = [
    {'nr':1, 'name':'Dragon Soars From the Shallows', 'start':1, 'end':118},
    {'nr':2, 'name':'Great Peng Spreads its Wings, Hating How Low the Heavens Are', 'start':119, 'end':234},
    {'nr':3, 'name':'Bload-Soaked Saber Trudges Across a Path of Bones', 'start':235, 'end':311},
    {'nr':4, 'name':'First Appearence of Primal Chaos Shakes Jiuli', 'start':312, 'end':472},
    {'nr':5, 'name':'Smiling Arrogantly, Rising to Fame Within the Seven Prefectures', 'start':473, 'end':648},
    {'nr':6, 'name':'Dragon Roars Through the Estern Wasteland, Unmatched', 'start':649, 'end':966},
    {'nr':7, 'name':'Heavenly Geniuses Rise Within the Centrail Plains', 'start':967, 'end':1300},
    {'nr':8, 'name':'Arrogantly Standing at the Front of the Pack', 'start':1301, 'end':1810},
    {'nr':9, 'name':'Slaughter Throhout the Five Regians', 'start':1811, 'end':2356},
    {'nr':10, 'name':'Darkness Shrouds the Heavens and Severs the Netherworld', 'start':2357, 'end':2842},
    {'nr':11, 'name':'Grandsmaster Instructors of the Imortal World', 'start':2843, 'end':3478},
    {'nr':12, 'name':'Violet Flame Bloodbath of Heavenly Geniuses', 'start':3479, 'end':10000}, # Still going on when making this
]

AUTHOR = 'Ordinary Magician (平凡魔术师)'

COVER_PATH= 'Nine-Star-Hegemon-Body-Art.jpg'


class EpubFixer:
    '''A class that fixes epubs'''
    def __init__(self, printing=True, make_folders=True):
        self.printing = printing
        if make_folders: self.make_folders()

    def fix(self, epub_path, output_folder, replace_dict=None, remove_list=None, volumes:list=None, description:str='', split:int=400, author:str='', title:str='', cover_img:str=None):
        '''Fixes the given book'''
        #if self.printing: print("Fixing ebook:", epub_path, end='')
        
        ## Getting the data from the the epub
        book = ep.read_epub(epub_path)
        if title == '': 
            title = book.get_metadata('DC', 'title')
            title = str(title[0][0])

        # Making the chapters 
        chapter_nr = 0
        chapters = {}
        for item in book.get_items():
            if item.get_type() == ebooklib.ITEM_DOCUMENT:
                chapter = None
                if item.id == "cover": # Identifying the cover page
                    cover_chap = True
                    continue
                else: 
                    cover_chap = False
                if item.file_name == "intro.xhtml": # Identifying the intro page
                    intro_chap = True
                    continue
                else:
                    intro_chap = False
                chapter_nr += 1

                chapter_body = item.get_body_content()
                chapter_lang = item.lang if item.lang else 'en'

                # Fixing the body:
                chapter_body = chapter_body.decode('utf-8')
                if replace_dict: # Replaces some special stuff
                    for f,r in replace_dict.items(): 
                        chapter_body = re.sub(f, r, chapter_body)
                        chapter_body = chapter_body.replace(f,r)

                if remove_list: # removes stuff
                    for r in remove_list:
                        chapter_body = chapter_body.replace(r, '')

                chapter_body = EpubFixer.replace_sensored(chapter_body)
                chapter_body = EpubFixer.replace_br_with_paragraph(chapter_body)
                chapter_body = EpubFixer.replace_bad_puntuation(chapter_body)
                chapter_body = re.sub(r"b'[.\s\S]*?<p>", '<p>', str(chapter_body)) # Remove som stuff at the start
                chapter_body = re.sub(r'.*<br\/>', '', str(chapter_body))
                chapter_body = re.sub(r"'b", '', str(chapter_body))
                chapter_title = EpubFixer.get_title(item) # must be after the sensoring and stuff due to formating 
                chapter_body = re.sub("<p>\s*" + chapter_title + '\s*</p>', '', str(chapter_body)) # Removing some chapter titles that is not needed
                chapter_body = re.sub(r"^[.\s\S]*?<p>", '<p>', str(chapter_body)) # removing anything befor the first paragraph
                chapter_body = chapter_body.strip()
                if chapter_body[-1] == "'": chapter_body = chapter_body[:-1]
                chapter_body += '</p>' # added at the end
                chapter_body = f'<h2>{chapter_title}</h2>' + chapter_body # Adding the chapter title
                #chapter_body = chapter_body.replace('.+','')

                chapter = ep.EpubHtml(title=chapter_title, file_name="chapter_" + f"{chapter_nr:0>5}" + '.xhtml',lang=chapter_lang)
                chapter.set_content(chapter_body)
                chapters[chapter_nr] = chapter

        
        ## Making the new books
        style = 'body { font-family: Times, Times New Roman, serif; }'
        nav_css = ep.EpubItem(uid="style_nav", file_name="style/nav.css", media_type="text/css", content=style)

        books = []
        if volumes:
            for volume in volumes:
                print(volume)
                v_nr = volume['nr']
                v_name = volume['name']
                v_title = f'{title} - Volume {v_nr}: {v_name}' 

                v_start = volume['start']
                v_end = volume['end']
                v_description = f'<p>Title: {v_title}<\p>\n<p>Chapters: {v_start} to {v_end} </p>\n{description}'

                # Setting up the book
                new_book = ep.EpubBook()
                new_book.set_identifier(f'Volume {v_nr}')
                new_book.set_title(v_title)
                new_book.set_language('en')
                new_book.add_metadata('DC', 'description', v_description)
                new_book.add_author(author)
                new_book.set_cover('cover.jpg', open(cover_img, 'rb').read())

                # Making the ntroduction chapter
                v_intro_chap = ep.EpubHtml(title='Introduction',file_name='intro.xhtml',lang='en')
                v_intro_chap.set_content(v_description)
                new_book.add_item(v_intro_chap)

                # Adding the chapters
                v_chapters = [v for k,v in chapters.items() if k>= v_start and k < v_end] # Get the chapters in the volume
                for v_chapter in v_chapters:
                    new_book.add_item(v_chapter)

                new_book.spine = [v_intro_chap] + v_chapters
                new_book.add_item(nav_css)
                new_book.add_item(ep.EpubNcx())
                new_book.add_item(ep.EpubNav())

                # Writing the book: 
                v_file_name = f'{title} - Volume {v_nr:0>2}'.replace(' ',' ').replace(':','-').replace('.',' ') + ".epub"
                v_output_path = Path(output_folder) / v_file_name
                
                if len(v_chapters) > 0: 
                    ep.write_epub(v_output_path, new_book, {})


    @staticmethod
    def get_title(item) -> str:
        '''Returns the text body of an item'''
        res = [item.title]
        #if res != '' or res != []: return res

        chapter_body = item.get_body_content()
        chapter_body.decode('utf-8')
        chapter_body = EpubFixer.replace_sensored(str(chapter_body))

        regex = '<title>(.*)<\/title>'
        res += re.findall(regex, chapter_body)

        regex = '(Chapter\s*\d*[\w\s\:]*)(?=<)'
        res += re.findall(regex, chapter_body)

        if res != '' or res != []: return max(res, key=len).strip()
        return ''





    @staticmethod
    def find_regex(epub_path:str, regex:str) -> dict:
        '''returns all hits for the regex in the epub - used to identigy what to replace'''
        pattern = re.compile(regex, flags=0) # to make it faster
        pattern = re.compile('.{0,10}' + regex + '.{0,10}')
        
        book = ep.read_epub(epub_path)
        for item in book.get_items():
            if item.get_type() == ebooklib.ITEM_DOCUMENT:
                #print('==================================')
                #print('NAME : ', item.get_name())
                #print(item.get_content())
                res = pattern.findall(str(item.get_content()))
                if len(res) > 0: 
                    print(res)
                #print(item.get_content())
                #print(EpubFixer.replace_br_with_paragraph(str(item.get_content())))
                print('_______________________')

    @staticmethod
    def replace_bad_puntuation(text:str) -> str:
        '''replaces somthing . sdfea with something. sdfadf'''
        return re.sub(r'\s\.', '.', text)

    @staticmethod
    def replace_br_with_paragraph(text:str) -> str:
        '''replaces <br/> with paragraph around'''
        pattern = r"<br/><br/><br/>"
        replace_with = r'</p>\n<p>'
        res =  re.sub(pattern, replace_with, text)
        res = re.sub(r'</body>', '</p></body>', res) # the end case
        res = re.sub(r"</p>", "", res, 1) # the first case
        #res =  re.sub(r'(\S.*?)?<br/>\s*', r'<p>\1</p>\n', text)
        return res


    @staticmethod
    def replace_sensored(text:str) -> str:
        '''Replaces sensored text (H.e.l.l) -> Hell'''
        return re.sub(r'\.(\w)', r'\1', text)

    @staticmethod
    def find_epubs(path) -> str:
        '''Finds epubs in the folder'''
        path = Path(path)
        p = path.glob('**/*')
        epubs = [x for x in p if x.is_file()]
        epubs = [x for x in epubs if x.suffix == '.epub']
        return epubs

    @staticmethod
    def make_folders(input_folder:str=INPUT_FOLDER, output_folder:str=OUTPUT_FOLDER) -> None:
        '''Makes the folders for the system - Really just a utils function'''
        Path(input_folder).mkdir(parents=True, exist_ok=True)
        Path(output_folder).mkdir(parents=True, exist_ok=True)



def main():
    fixer = EpubFixer()
    epubs = fixer.find_epubs(INPUT_FOLDER)
    for epub in epubs:
        #fixer.find_regex(epub, '\.\+')
        fixer.fix(epub_path=epub, output_folder=OUTPUT_FOLDER, replace_dict=REPLACE, remove_list=REMOVE, description=DESCRIPTION, volumes=VOLUMES, title=TITLE, cover_img=COVER_PATH, author=AUTHOR)

if __name__=="__main__":
    main()